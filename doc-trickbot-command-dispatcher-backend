RU:
# Серверная часть

1. Задача серверной части принимать HTTP-запросы и отвечать на них. В процессе работы необходимо взаимодействовать с
СУБД PostgreSQL. СУБД может находиться физически на другой  машине, поэтому надо предусмотреть такой вариант развёртывания
системы: может работать несколько серверных приложений на разных физических серверах и одна СУБД на отдельномом  физическом сервере.


1.1 База данных хранит информацию о клиентах, файлах для них (команда /5/, пункт 3.3) и событиях связанных с клиентами.
Каждый клиент имеет ряд неотъемлемых свойств: Тег группы, Id клиента, операционная система, ip-адрес, geoip (страна),
Importance, userdefined, когда был зарегистрирован, когда выходил в последний раз в онлайн (команда /0/,  пункт 3.1).
Importance и  userdefined - это два целых числовых параметра (отрицательные числа, положительные числа и ноль),
устанавливаются или изменяются другими серверными приложениями или администраторм/оператором сервера.

2. Работа с сервером осуществляется через HTTP-запросы. 
Они могут быть как GET, так и POST.
Между сервером и клиентом может стоять сколько угодно reverse-proxy, load-balancer и  DNAT.
Таким образом, единственный способ узнать ip-адрес клиента который послал запрос - это параметр client-self-ip-address
в команде /0/ (пункт 3.1). Других способов нет, не будет и быть не может в принципе.

2.1 Каждый запрос содержит в URI три компонента разделённых символом "/" 

```тег группы, id клиента, код команды. /<group-tag>/<clientid>/<ccode>/,```

где group-tag - тег группы,   
    clientid - id клиента,    
    ccode - код команды.

2.1.1 Тег группы - это произвольная строка состоящая из символов (a-z) и цифр (0-9). Параметр не чувствителен к регистру.

2.1.2 Id клиента - это строка состоящая из двух компонентов разделённых точкой.
Первая часть имеет формат <name>_XYYYYYYY, где name это некоторое имя которое может как-то  идентифицировать машину
(имя компьюетра или имя пользователя, в зависимости от типа операционной системы),
X - символ обозначающий тип системы на которой работает клиент (W -  windows, L - linux, A - андроид, M - Mac OS),
YYYYYYY - 3-7 цифр содержащих major-version, minor-version и build операционной системы если таковые имеются у системы
(например,  длЯ 6.1 build 7600 это будет 617600).
Вторая часть содержит 32 случайных символов 0-9, A-F.
Пример id клиента - ```QWERTY_W617600.11223344556677889900AABBCCDDEEFF```.
Параметр не  чувствителен к регистру.

2.1.3 Код команды - это число от 0 до 999.
2.2 Четрвёртый и последующий компоненты в URI, а также тело запроса и ответа зависят от кода команды
2.3 Кадлый ответ сервера может быть со следующими HTTP-кодами: 200, 403, 404

# 3. Команды
## 3.1 /0/ - инициализация цикла команд /1/. 

Принимает 4 дополнительных параметра:

* system-version - наименование операционной системы c версией, серви паком и архитектурой (32, 64 bit)
* client-version - версия клиента, произвольное число больше 1000
* client-self-ip-address - собственный внешний ip-адрес (ipv4 и ipv6) клиента в строковом представлении.
  Добывается самим клиентом средствами выбранными по усмотрению  разработчика этого клиента.
* token-string - случайная строка длиной от 16 до 32 символов.
  Может содержать большие и маленькие английские символы и цифры от 0 до 9. Чувствителен к регистру
* devhash - идентификатор оборудования. Произвольная HEX-строка (символы 0-9, A-F) представляющая некоторый 256-битный хеш, 
который зависит оборудования или операционной системы  на которых работает клиент

Формат запроса:
```/<group-tag>/<clientid>/0/<system-version>/<client-version>/<client-self-ip-address>/<devhash>/<token-string>/```

Ответом сервера является файл (content-type: binary) следующего содержимого:

```/1/<group-tag>/<clientid>/<token-string>/<binary-content-length>/\r\n
<binary-content>\r\n
<server-sign>```

token-string - строка скопированная из GET-запроса
binary-content-length - длина блока binary-content в байтах записанная числов в виде строки
binary-content - блок бинарных данных
server-sign - цифровая подпись сервера, в неё включает содержимое ответа от первого байта до второго перевода строки \r\n (символы \r\n включаются в цифровую подпись)

Если при получении команды клиента нет в базе, то он должен быть добавлен в неё, если он есть, то информация в базе
(тег группы, ip-адрес, версия клиента, операционная  система) должна быть обновлена.

Выборка файла.
Блок бинарных данных данном случае это файл extcfg, который выбирается по тем же правилам, что и в команде /5/. Если

Приём команды /0/ означает, что с текущего момента клиент находится в онлайне. Возможно получение несколько раз подряд
команды /0/ от одного клиента - это нормальная ситуация.

## 3.2 /1/ - выдача клиенту команды.

Имеет только один дополнительный параметр -

  * token-string (который будет продублирован в ответе).

Разрешается обрабатывать данную команду только в том случае если в последний раз  команда /0/ приходила от данного клиента
не более суток назад (время может быть изменено через конфиг-файл серверного приложения),
в противном случае сервер должен ответить HTTP 403.

Формат ответа на данную команду:

```/<incode>/<group-tag>/<clientid>/<token-string>/<cmd-id>/\r\n
<command-params>\r\n
<server-sign>```

* incode - код выданной команды
* token-string - строка скопированная из параметра команды /1/ из GET-запроса
* cmd-id - уникальный идентификатор выданной команды, произвольная строка с большими и маленькими английскими символами, цифрами от 0 до 9 и символомами -,+,точка,#.  Чувствителен к регистру.
* command-params - произвольная строка с параметрами (не должны содержаться символы \r\n так как это обозначает конец строки)
* server-sign - цифровая подпись сервера, в неё включается содержимое ответа от первого байта до второго перевода строки \r\n (символы \r\n включаются в цифровую подпись)

## 3.3 /5/ - выдача клиенту файла. 

Имеет только один дополнительный параметр - имя файла. Имя файл не чувствительно к регистру. 
В ответ на эту команду сервер должен выдать файл (content-type: binary) предназначенный для этого клиента.

Во внутреннем хранилище серверного приложения (базе данных) должно находиться произвольное число файлов, 
каждый файл может иметь фильтр по следующим параметрам: 
  фильтр группы (задаётся списком like-паттернов разделенных пробелами),
  исключающий фильтр группы (задаётся списком like-паттернов разделенных пробелами, если есть хотя бы одно совпадание из этого списка, то файл считается не подходящим клиенту),
  geoip, 
  операционная система, 
  importance (диапазон начало-конец), 
  userdefined (диапазон начало-конец), 
  id клиента (строгое соответствие), 
  приоритет. 

Приоритет - это  произвольное положительное целое число. 
Тег группы может задаваться не только строгим наименованием группы, но и как like-паттерн из языка SQL.
Сервер может располагать несколькими файлами с одним и тем же именем, но с разными фильтрами. 
Если клиенту подходит несколько файлов  сразу, то должен быть выдан тот, у которого в фильтре значение приоритета больше 
чем у остальных. База должна не допускать указание нескольких файлов с одинаковым приоритетом.

Если нет ни одного файла удовлетворяющего по условиям данному клиенту, то сервер должен ответить HTTP 404. 

Если пришёл запрос от клиента от которого никогда не приходило  запроса /0/, то у него надо проверить только тег группы 
(так как другой информации ещё нет в базе).

## 3.4 /10/ - получение от клиента отчёта о выполненной им команды. 

Формат запроса для команды /10/:

```/<group-tag>/<clientid>/10/<incode>/<cmd-id>/<result-code>/```

incode - код выполненной команды
cmd-id - идентификатор выполненной команды.
result-code - код результата выполненной команды. Число от 0 до 999

При получении этой команды, команда которая находится в очереди у данного клиента должна быть удалена из очереди 
ВНЕ зависимости от того какой result-code прислал клиент. 

Если  в очереди нет команды с указанным кодом и идеентификаторорм указанных в параметрах incode и cmd-id (обязательна 
проверка обеих значений), то это считается нештатной ситуацией  должно быть занесено в некоторый журнал или другую 
сущность, которую потом может посмотреть администратор сервера.

Ответ на данную команду всегда одинаковый HTTP 200, Content-type: text/plain, содержимое тела ответа "/1/"

## 3.5 /14/ - сохранение пары ключ-значение в БД.

Для возможности просмотра этих значений администратором или оператором.
Формат запроса:
```/<group-tag>/<clientid>/14/<name>/<value>/0/```

* name - ключ. Произвольная строка с английскими заглавными и строчными буквами, цифрами и символами точка, "+" и "-".
* value - значение. Произвольная строка, все специальные символы должны быть закодированы в urlencode.
* Третий параметр всегда ноль.


Ответ на данную команду всегда одинаковый HTTP 200, Content-type: text/plain, содержимое тела ответа "/1/"

## 3.6 /15/ - чтение пары ключ-значение из БД.

```/<group-tag>/<clientid>/15/name```

Результат:
    HTTP 200 -- тело: значение
    HTTP 204 -- значение не найдено

## 3.7 /23/ - выдача клиенту конфига.

Имеет только один дополнительный параметр - версию текущего конфига клиента. Версия - это число от 0 до 2^32-1. 
Пример запроса клиента:
```/<group-tag>/<clientid>/23/<current-config-version>/```
current-config-version - текущая версия конфига.

Пример ответа сервера:
```/23/<group-tag>/<clientid>/<config-version>/<binary-content-length>/\r\n
<binary-content>\r\n
<server-sign>```
  binary-content - бинарное содержимое конфига
  config-version - версия конфига в binary-content 
  binary-content-length - длина binary-content в байтах записанная в виде строки

Во внутреннем хранилище серверного приложения (базе данных) должно находиться произвольное число конфигов. 
Подобно файлу конфиг имеет неотъемлемый параметр - версию - произвольное числовое значение, которое задаётся администратором или вышестоящей логикой. 
Каждый конфиг может иметь фильтр по следующим параметрам: 
  * тег группы (может задаваться как like-паттерн из языка SQL),
  * geoip, 
  * операционная система, 
  * importance (диапазон начало-конец), 
  * userdefined (диапазон начало-конец), 
  * id клиента (строгое соответствие).  
  
Сервер может располагать несколькими конфигами с одной и той же версией, но с разными фильтрами. 
Все конфиги с версией равной или меньшей чем та, которую указал клиент в запросе, отбрасываются. 
Клиенту может быть выдан конфиг с версией строго большей чем, та которую он указал в запросе. 
Если клиенту подходит несколько конфигов  сразу, то должен быть выдан тот, у которого версия больше, чем у остальных. 
База должна может допускать хранение конфигов с одинаковой версией.
Если нет ни одного файла удовлетворяющего по условиям данному клиенту, то сервер должен ответить HTTP 404. 
Если пришёл запрос от клиента от которого никогда не приходило  запроса /0/ (либо он приходил давно), то сервер отвечает сразу HTTP 403, без каких либо проверок.

## 3.8 /25/ - выдача клиенту ссылки.

Команда не имеет параметров.
Пример запроса клиента:
```/<group-tag>/<clientid>/25/<token-string>/```
token-string -идентичен параметру в команде /1/ 

Пример ответа сервера:
```/25/<group-tag>/<clientid>/<token-string>/\r\n
<link>\r\n
<server-sign>```
Во внутреннем хранилище серверного приложения (базе данных) должно находиться произвольное число ссылок. 

Ссылка - это произвольная строка построенная по правилам URL. 
Подобно файлам и конфигам, ссылка имеет неотъемлемый параметр - срок действия в минутах, с момента добавления администратором или вышестоящей логикой. 

Каждая ссылка может иметь фильтр по следующим параметрам: 
  * тег группы (может задаваться как like-паттерн из языка SQL),  
  * geoip, 
  * операционная система, 
  * importance (диапазон начало-конец), 
  * userdefined (диапазон начало-конец), 
  * id клиента (строгое соответствие).  

Сервер может располагать несколькими одинаковыми ссылкам, но с разными фильтрами. 
При выборке ссылки для клиента должны быть отброшены всех ссылки, срок действия которых истёк. 
Если клиенту подходит несколько ссылок сразу, то должна быть выдана та, актуальность которой истекает позже всех остальных (именно актуальность, т.е. дата-время добавления + срок действия в минутах).
Если нет ни одной ссылки удовлетворяющего по условиям данному клиенту, то сервер должен ответить HTTP 404. 
Если пришёл запрос от клиента от которого никогда не приходило  запроса /0/ (либо он приходил давно), то сервер отвечает сразу HTTP 403, без каких либо проверок.

# 3.9 /63/ - приём данных модуля.

Команда имеет следующие параметры: 
  * имя модуля, 
  * ctl к модулю, 
  * результирующая строка ctl, 
  * вспомогательный тег, 
  * ctl_OutData. 
  
Причём результирующая строка ctl, вспомогательный тег и ctl OutData являются опциональными. 
Параметр "ctl_OutData" является блоком произвольных бинарных данных и передаётся в теле через multipart/form-data, имя параметра внутри multipart/form-data -- "noname". 
Если в запросе присутствует ctl_OutData, то запрос передаётся методом POST.

Пример запроса клиента
```/63/<module name>/<ctl>/<ctl-result-string>/<aux-tag>/```

* module name - строка состоит только из английских букв, максималная длина 64 символа. Предполагается, что на этом столбце в таблице будет стоять индекс.
* ctl - строка состоит только из английских букв и цифр, максималная длина 64 символа. 
* ctl-result-string - строка в формате base64. Бекенд должен сохранить эту строку в базе в декодированном виде. Максимальная длина после декодирования 1024 символа
* aux-tag - вспомогательный тег, строка состоит только из английских букв и цифр, максималная длина 128 символов. Поле необходимо для удобства поиска в таблице, предполагается, что на этом столбце в таблице будет стоять индекс.
* ctl_OutData - передаётся в теле POST-запроса и  содержит блок произвольных бинарных данных. Максимальный размер 32 МБ. 

Ответ сервера либо всегда  200 - "/1/", либо 403 если клиента нет в базе или он слишком давно присылал /0/
Сервер должен хранить всю информацию полученную через команду /63/, а именно: 

  * дата время, 
  * сlientid, 
  * ctl, 
  * ctl-result-string, 
  * aux-tag 
  * ctl_OutData. 
  
Вся информация должна храниться в отдельных столбцах для возможности выборки и фильтрации (разумеется, кроме ctl_OutData, для неё достаточно столбца с бинарным типом данных).

## 3.10 /64/ - отчет о событии в модуле.

Команда имеет следующие параметры: 
* имя модуля, 
* имя события, 
* информация о событии, 
* вспомогательный тег, 
* данные события. 

Причём информация о событии, вспомогательный тег и данные являются опциональными. 

Информация о событии -- это строка в кодировке UTF-8 максимальной длины 64 КБ (байтов, а не символов). 

Параметр с данными является блоком произвольных бинарных данных и передаётся в теле через multipart/form-data, 

Имя параметра внутри multipart/form-data -- "data", а имя параметра с информацией о событии -- "info". 

Если в запросе присутствует данные или информация о событии, то запрос передаётся методом POST.

Пример запроса клиента
```/64/<module name>/<event-name>/<aux-tag>/```

module name - строка состоит только из английских букв, максималная длина 64 символа. Предполагается, что на этом столбце в таблице будет стоять индекс.

event-name - строка состоит только из английских букв и цифр, максималная длина 64 символа. 

aux-tag - вспомогательный тег, строка состоит только из английских букв и цифр, максималная длина 128 символов. 
  Поле необходимо для удобства поиска в таблице, предполагается, что на этом столбце в таблице будет стоять индекс.

Ответ сервера либо всегда  200 - "/1/", либо 403 если клиента нет в базе или он слишком давно присылал /0/
Сервер должен хранить всю информацию полученную через команду /64/, а именно:
 
* дата время, 
* сlientid, 
* event name, 
* info, 
* aux-tag 
* data. 

Вся информация должна храниться в отдельных столбцах для возможности выборки и фильтрации (разумеется, кроме data, для неё достаточно столбца с бинарным типом данных).

# 4. Каждый клиент должен иметь свою очередь команд.
 
Команды добавляются в очередь оператором или определёнными механизмами серверного приложения. 
Команды удаляются из очереди  только тогда, когда клиент присылает отчёт об их выполнении с помощью команды /10/. 
Пока он отчёт не пришёл, команда будет стоять в очереди, ДАЖЕ если это приведёт к тому, что  клиент запросит несколько 
раз одну и ту же команду. При получении отчёта о выполении комада должна быть удалена из очереди ВНЕ зависимости от того 
какой result-code прислал  клиент. 

Каждая команда имеет два атрибута: 
  * код команды (число от 0 до 999)  
  * параметр команды - ANSI-строка произвольной длины.
  
# 5. Цифровая подпись сервера
которая фигурирует в ответе некоторых команд является подписью ECDSA 256bit. 
В текущей версии не используется, вместо неё должна быть строка  "1234567890"

# 6 DataPost 

- это отдельная версия серверного приложения которая принимает ТОЛЬКО команду /60/ и больше ничего.
6.1  /60/ - не используется в текущей версии системы

# 7 Функционал IdleCommands. 

Сервер должен предоставить некоторое API (в виде хранимых процедур), которое будет создавать "ждущие команды". 
Функционал ждущих команд подразумевает, что есть группа команд, которая изначально не имеет клиентов-получателей. 
Каждая группа ждущих команд имеет следующие параметры: 
  * код команды, 
  * параметр команды, 
  * количество команд, 
  * фильтры geoip (до 10 стран) 
  * фильтр операционной системы
  * фильтр группы. Фильтр может задаваться как like-паттерн из языка SQL, либо несколько like-паттернов разделенных пробелами
  * исключающий фильтр групп. Фильтр может задаваться как like-паттерн из языка SQL, либо несколько like-паттернов разделенных пробелами. Если тег группы клиента подходит хотя бы под один перечисленный в этом параметре паттерн, то ждущая команда считается как НЕ подходящая для него. Непротиворечивость этого параметра с предыдущим параметром обеспечивается администратором.
  * фильтр importance (начало и конец диапазона) 
  * фильтр user defined (начало и конец диапазона).
  
Каждый приходящий запрос /1/ клиента, если у него нет в очереди невыполненных команд, проверяется по фильтрам групп "ждущих команд", при этом должны быть исключены те группы, из которых ранее были выданы команды этому клиенту. 
Если такие фильтры находятся, то берётся первый фильтр (если таковых нашлось более одного), счётчик команд этой группы уменьшается на единицу, после чего код команды и её параметр добавляется в очередь команд этого клиента. 
Важное требование: одному клиенту из каждой группы "ждущих команд" команда может быть выдана только один раз.
Также необходимо предоставить функционал управления группами "ждущих команд". Итоговый функционал (хранимые процедуры): 
1. добавить группу
2. удалить группу
3. получить список групп (в списке у каждой группы должны быть все параметры, плюс количество оставшихся команд в группе и изначальное число команд в группе)
4. увеличить количество команд (позаботиться об атомарности операции и разрешении конфликта, когда из-за одновременности операций админа и бэкендов количество стало отрицательным)
5. изменить параметр команды (но не код команды)
6. добавить страну в фильтры (убирать нельзя)

# 8 API управления сервером. 

Сервер на отдельном порте предоставляет API для управления некоторыми функциями сервера. Порт API должен настраиваться через конфиг сервера.

8.1 Доступ по API происходит 
по протоколу HTTPS, вне зависимости от номера порта сервера. HTTP-запрос может быть как GET, так и POST. POST-запрос используется если один из аргументов API представлен в виде бинарного блока данных. Контроль доступа осущестсвляется по двум параметарам: apikey и apikeypass. 

8.1.1 Формат запроса по API выглядит так:

```/<apikey>/<apikeypass>/<function>?param_name1=<param1>&param_name2=<param2>.....```

Если функция принимает некоторый бинарный блок данных, то запрос осуществляется методом POST, а блок данных передаётся внутри multipart/form-data с именем "bdata"

function - имя функции, строка чувствительна к регистру, может содержать большие и маленькие английские буквы и цифры

8.2 Каждый apikey имеет следующие атрибуты: 
  список функций которые ему разрешено выполнять, 
  диапазон ip-адресов с которых ему разрешён доступ. 
  
  Диапазон задаётся в формате CIDR. Например, 1.2.3.4/24 - диапазон от 1.2.3.0 до 1.2.3.255, 1.2.3.4/32 - единичный ip-адрес, 1.2.3.4/0 - любой ip-адрес. 

Список всех apikey и apikeypass с их настройками (список функций и диапазон ip) должен задаваться через специальную таблицу базе данных

8.2.1 IP-адрес инициатора запроса извлекается из HTTP-заголовка "X-Forwarded-For". Если этого заголовка нет, то запрос должен быть отброшен с кодом HTTP 403.

## 8.3 Функции API

### 8.3.1 GetGroupData - получение информации по группам. 

Принимает один параметр: период времени в минутах. 
Функция должна выдавать отчёт об активности по группам за указанный период времени до настоящего момента. 
Данные о клиенте включаются в отчёт если у него была активность в указанный период времени.
Отчёт по группам представляет из себя текстовый файл. Формат данных по группам :

```<group> <client_count> <first_created>```

* group - имя группы
* client_count - количество уникальных клиентов
* first_created - время первой регистрции самого раннего клиента в этой группе. Формате времени: epoch time.

Строки с информаций о группах разделяются парой "\r\n".

Например:

```qwerty1 151 1451278532
test 12 1358237562
test2 1005 1428237531
test111 100 1438257732```

Функция в случае успеха отвечает HTTP 200 c текстовым файлом с данными по группам, в противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.2 UploadFile - загрузка файла на сервер. 

Принимает параметры в следующем порядке:

* id - число (если адресуется конкретный файл для замены )
* имя файла (filename)
* group -- группа. (если не указан то "*") 
* sys_ver (если не указан то "*")  
* country (если не указан то "*")
* client_id (если не указан то 0)
* importance_low (если не указан то 0)
* importance_high (если не указан то 100)
* userdefined_low (если не указан то 0)
* userdefined_high (если не указан то 100)
* priority (число)
* bdata -- содержимое файла внутри multipart/form-data 

Перед загрузкой файла в базу приоритет файла вычисляется следущим образом: вычисляется максимальное значение приоритета в таблице и прибавляется единица. 
Функция в случае успеха отвечает HTTP 200 /1/, в противнос случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.3 UploadConfig - загрузка конфига на сервер.

* id -- если нужно заменить линк
* version версия конфига
* group группа 
* country (если не указан то "*")
* client_id (если не указан то 0)
* importance_low (если не указан то 0)
* importance_high (если не указан то 100)
* userdefined_low (если не указан то 0)
* userdefined_high (если не указан то 100)
* sys_ver
* bdata --  содержимое конфига внутри multipart/form-data 

Функция в случае успеха отвечает HTTP 200 /1/, в противнос случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.4 UploadLink - загрузка ссылки на сервер.

* id -- если нужно заменить линк
* expiry_at -- unixtime (целое) - время протухания ссылки
* sys_ver -- версия системы
* group -- группа 
* country -- страна
* client_id (если не указан то 0)
* importance_low (если не указан то 0)
* importance_high (если не указан то 100)
* userdefined_low (если не указан то 0)
* userdefined_high (если не указан то 100)
* bdata -- полный текст ссылки внутри multipart/form-data

Функция в случае успеха отвечает HTTP 200 /1/, в противнос случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.5 PushBack - добавление команды в очередь клиента

* cid - строковый идентификатор клиента. Часть идентификатора находящаяся после точки. Например, 4D2873436FA2371F319DD55C147DC9B2
* code - код команды, число
* param - параметр команды, строка. При передаче через ссылку в GET, она может быть в формате urlencode

Функция в случае успеха отвечает HTTP 200 /1/, если несуществующий cid - 404. 
В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.6 GetFilesList - получить список всех файлов со всеми параметрами.

Функция в случае успеха отвечает HTTP 200 text/plain с перечислением всех файлов, которые есть в таблице с файлами. 
Одна строка - один файл, разделитель строк - "\r\n". Внутристроковый разделитель параметров - табуляция (9). 
Параметры следуют в следующем порядке: id, имя, приоритет, группа, geo, importance_low, importance_high, system, userdefined_low, userdefined_high. 

В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).


### 8.3.7 DeleteFile - удаление файла
* id - идентификатор удаляемого файла

Функция в случае успеха отвечает HTTP 200 /1/, если несуществующий id - 404. В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.8 GetLastEventData - получить последние данные из указанного модуля и события
* cid - строковый идентификатор клиента. Часть идентификатора находящаяся после точки. Например, 4D2873436FA2371F319DD55C147DC9B2
* module - имя модуля 
* event - имя события

Функция в случае успеха отвечает HTTP 200 и octet-stream с содержимым данных присланных последний раз по указанному модулю и событию, если несуществующий cid - 404, если нет ни одного события удовлетворящего требованиям (module, event) - 404, если событие есть, но данных нет, то 204. В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.9 GetOnline - получить список всех клиентов по последней активности.
* period - период активности в секундах.

Функция в случае успеха отвечает HTTP 200 text/plain с перечислением строковых идентификаторов клиентов, которые были активны в указанный периол времени. 

Одна строка - один идентификатор, разделитель строк - "\r\n". В идентификаторе указывать только часть после точки.

В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.3.10 GetLastActivity - получить время последней активности клиента
* cid - строковый идентификатор клиента. Часть идентификатора находящаяся после точки. Например, 4D2873436FA2371F319DD55C147DC9B2

Функция в случае успеха отвечает HTTP 200 и text/plain в котором в виде строки находится EPOCH-time с последней активностью указанного клиента, если несуществующий cid - 404. В противном случае 403 (если параметры не указаны, неправильный формат, неправильные данные apikey/apikeypass или где-то ошибка).

### 8.4.11 GetEventsGroup - получить события в заданном временном диапазоне по указанному модулю.

* module -- имя модуля.
* from -- дата, с которой начинаем выборку (YYYY-MM-DD HH:MM:SS)
* to -- дата, до которой выбираем выборку (YYYY-MM-DD HH:MM:SS)

Результат:

    7E1CA48485E507C4D1490765637E019B - /FF-14-08/Chrome-14-08/Edge-14-08/IE-14-08/
    49DABAE0E9C47C9C04A274A84E511113 - /Chrome-10-08/IE-07-08/


### 8.4 По всей активности API должен вестись журнал. 

Должна храниться следующая информация: дата-время, apikey, искомый адрес, функция. Хранить информацию только я успешно выполненных запросов, все остальные логировать в общий текстовый лог сервера.

# 9 Лог клиента. 

У каждого клиента должен быть свой журнал активности. 
В этот журнал активности должна заноситься информация обо всех командах серверу кроме команды /1/. 
Также должна заноситься информация обо всех выданных командах клиенту. 
Если была выдана команда из групп commands_idle, то должен быть сохранен идентификатр группы commands_idle.

В журнале активности должна храниться следующая информация:

* дата время
* client_id
* код команды, входящей или исходящей. 
* Дополнительная информация в виде строки.
 
** Для исходящих команд информации не будет.
** При получении команды /10/ в данное поле надо сохранить код выполненной команды.
** При "не холостом" выполнении команды /1/, в это поле должен быть сохранён код выданной команды. 
** Для commands_idle это будет  идентификатр группы. 
** Для /63/ это будет имя модуля и  ctl (через пробел). 
** Для /64/ это будет имя модуля и имя события и aux-tag (через пробел).
** Для /23/ это будет версия выданного конфига. 
** Для /5/ это будет id выданного файла. 
** Для /25/ это будет текст ссылки. 
** Для /10/ это будет идентификатор выполненной команды (cmdid) и код результата.
 
# 10 Importance. 

Механизм Importance должен позволять формировать целочисленное значение от 0 до 100 включительно на основе событий связанных с клиентом.
 
## 10.1 Каждое событие имеет модификаторы значения Importance, их три: preplus, mul, postplus. 

Все имеют тип float с точностью как минимум 4 знака после запятой и не могут принимать значение null и . 

Preplus и postplus могут принимать значения от -100, до 100 включительно, mul может принимать значения от 0 до 100 включительно. 

Также событие имеет класс и дополнительный параметр зависящий от класса.

Может быть сколько угодно событий с одним и тем же классом, но не может быть двух событий у которых класс и дополнительный параметр одинаковые. 

У каждого клиента событие может сработать только один раз.

После того, как сработало событие значение importance перевычисляется по следующей формуле:

newimportance = (oldimportance+preplus)*mul+postplus

Если newimportance получается менее 0 или более 100, то ему присваивается значение соответственно  0 или 100. 
Также перед сохранением в базу значение newimportance округлятся до целого значения с использованием стандартной функции округления.

Помимо прочего у каждого клиента должен параметр (флаг), который запрещает автоматическое изменение значения importance. 

По-умолчанию, он у всех снят.

Списоб событий глобален для всех клиентов. 
ОН должен меняться через СУБД, а не через конфиги. 
При удалении события из списка (таблицы) с событиями, никаких пересчётов importance не происходит. 
Сам список событий изменяется редко (не чаще чем раз в 30 минут), поэтому допускается кеширование списка событий. 

Регулярность обновления должна задаваться через конфиг. 

## 10.2 В текущей реализации сервер должен поддерживать следующие классы  событий

### 10.2.1 Класс - "online". Команда /0/ .  

Дополнительный параметр - количество полученных команд /0/ . Например, указаны следующие события: 
id1 - online(1),  preplus=xx, mul= xx, postplus=xx
....
id16 - online(4)),  preplus=xx, mul= xx, postplus=xx 
....
id23 - online(7)),  preplus=xx, mul= xx, postplus=xx
Таким образом при первой полученной команде /0/ сработает событие "id1", 
     при второй полученной команде событие  "id1" уже НЕ сработет, 
     при третьей тоже не сработает, 
     а при четвёртой полученной команде /0/ сработает событие "id16", 
     при пятой и шестой командах /0/ события "id1" и "id16" не сработают, 
     при седьмой полученной команде /0/ сработает событие "id23".

Если параметр равен 0 или null, то он расценивается как единица.

### 10.2.2 Класс - "age". Время после регистрации. 

Дополнительный параметр - количество минут прошеднее после самой первой команды /0/, которая послужила причиной регистрации клиента в базе. 

Количество минут сравниваниется согласно операции "больше или равно" (">=").

Проверка на событие происходит только при получении команды /0/ или /1/.

Например, имеются следующие события:

id2- age(30), preplus=0, mul= 1.0, postplus=10
....
id15- age(90), preplus=0, mul= 0.2, postplus=0

Таким образом, при полученни команды /0/ или /1/ получилось так, что прошло 37 минут с момента регистрации клиента, то срабатывает событие "id2". 
Потом если при получении /0/ или /1/ получилось так, что прошло 123 минуты, то сработает "id15". 
В итоге значение importance будет равно 2 (в начале importance равно 0, потом после "id2" будет  (0+0)*1+10 = 10, а потом после "id15" будет (10+0)*0.2+0=2)

Также возможет другой вариант: в какой-то момент при полученни команды /0/ или /1/ получилось так, что с момента регистрации клиента прошла 201 минута, 
то сработают одновременно и событие "id2", и событие  "id15". В этом случае мы получим одновременное срабатывание обоих событий, те же вычисления и значение importance = 2.

### 10.2.3 Класс - "geo". Страна. 

Дополнительный параметр - наименование страны, строка. Проверка на событие осуществляется только при получении команды /0/.

### 10.2.4 Класс - "devhash_dup". Имеется другой клиент, у которого devhash точно такой же. 

Дополнительный параметр не используется. 

Проверка на событие осуществляется только при получении команды /0/. Событие срабатывает в случае сли в при получении команды /0/ при сохранении его в таблицу выясняется, что точно такой же в devhash имеется у другого клиента.

### 10.2.5 Класс - "command_complete". Успешное выполнение исходящей команды. 

Дополнительный параметр - количество выполненных команд. 
Проверка на событие осуществляется только при получении команды /10/. 
Если параметр равен 0 или null, то он расценивается как единица.

### 10.2.6 Класс - "geo_change". 

Смена страны. Никаких дополнительных параметров нет. 
Проверка на событие осуществляется только при получении команды /0/.

## 10.3 По каждому сработанному событию в логе искомого клиента (пункт 9) должна быть запись с идентификатором сработавшего события


класс online -  счетчик индивидуальный
класс age - глобальный, время отсчитывается от времени указанном в столбце created_at
класс geo - счетчик не нужен
класс devhash_dup - счетчик не нужен
класс command_complete - счетчик индивидуальный

## 11 Механизм автодобавления команд клиенту 

Реализовать механизм автодобавления команд клиенту при получении отчетов о событиях (команда 64). 

Триггер автодобавления должен реагировать на имя модуля, имя события и поле info, при их возникновении сервер должен добавлять команду с указанным кодом и параметром. 

Поле info должно проверяться по регулярному выражению. 
Таким образом, если поле info содержит "qrrr45werty", то проверка по "r45" должна дать положительный результат, а проверка по "^r45" отрицательный.

Помимо прочего триггер должен содержать целочисленный параметр ограничивающий минимальную частоту срабатывания этого триггера на каждом конкретно взятом клиенте. 
Параметр задается в секундах. 
Если он равен 0, то ограничения нет. 
Например, если равен 300 секунд, то если у данного клиента триггер сработал 180 секунд назад, то команду вставлять в очередь не надо.
 
Управление списком автодобавления должно осуществляться через таблицу. 

Таблицу можно кешировать, регулярность обновления кеша должна задаваться через конфиг в секундах.

-------------------------------

## 12 Продвинутый фильтр

В админку стучатся непонятные боты,
 нужно добавить фильтр, чтобы отсеивать таких ботов, не выдавать им конфиги (команды 23, 5) и
 команды на запуск модулей и файлов (команды 42, 43, 44, 45, 46, 47, 48, 50, 62):
 1) по ip (можно указать конкретные ip, так и целый диапазон)
 2) по id:
  Kevin_W617601* - все боты, id которых начинающиеся с Kevin_W617601
  *Kevin* - все боты, содержащие в id Kevin
  можно указать список таких фильтров
 3) по Version:
 	 Version < 1080
 	 Version == 1027
 	 Version != 1089
 	 Version > 1099
 4) по Group:
 	aver*
 5) по System:
 	Microsoft Windows 10 Pro
	Microsoft Windows 7 Professional
	Microsoft*
	*Microsoft*
 Данные фильтры можно группировать, например:
  Version < 1080
  System: *Microsoft*
	и т.д.

Сделать управление фильтром через апи, или как ты сделал для мавелека, чтобы он сделал в админке раздел







#EN
# Server side

1. The task of the server part is to accept HTTP requests and respond to them. In the course of work, you need to interact with
DBMS PostgreSQL. The DBMS can be physically located on another machine, so you need to provide for such a deployment option
systems: several server applications can run on different physical servers and one DBMS on a separate physical server.


1.1 The database stores information about clients, files for them (command /5/, item 3.3) and events related to clients.
Each client has a number of inherent properties: group tag, client id, operating system, ip address, geoip (country),
Importance, userdefined, when he was registered, when he went online for the last time (command /0/, point 3.1).
Importance and userdefined are two integer numeric parameters (negative numbers, positive numbers and zero),
set or modified by other server applications or by the administrator/server operator.

2. Work with the server is carried out through HTTP requests.
They can be either GET or POST.
There can be any number of reverse-proxy, load-balancer and DNAT between the server and the client.
Thus, the only way to find out the ip address of the client that sent the request is with the client-self-ip-address parameter
in the /0/ command (clause 3.1). There are no other ways, there won't be, and there can't be, in principle.

2.1 Each request contains three components in the URI separated by "/"

```Group tag, client id, command code. /<group-tag>/<clientid>/<ccode>/,```

where group-tag is the group tag,
    clientid - client id,
    ccode - command code.

2.1.1 A group tag is an arbitrary string consisting of characters (a-z) and numbers (0-9). The parameter is not case sensitive.

2.1.2 The client id is a string consisting of two components separated by a dot.
The first part has the format <name>_XYYYYYYY, where name is some name that can somehow identify the machine
(computer name or username, depending on the type of operating system),
X - a symbol indicating the type of system on which the client is running (W - windows, L - linux, A - android, M - Mac OS),
YYYYYYY - 3-7 digits containing the major-version, minor-version and build of the operating system if the system has any
(for example, for 6.1 build 7600 it will be 617600).
The second part contains 32 random characters 0-9, A-F.
An example client id is ```QWERTY_W617600.11223344556677889900AABBCCDDEEFF```.
The parameter is not case sensitive.

2.1.3 The command code is a number from 0 to 999.
2.2 The fourth and subsequent components in the URI, as well as the body of the request and response, depend on the command code
2.3 Each server response can be with the following HTTP codes: 200, 403, 404

# 3. Teams
## 3.1 /0/ - initialization of the command loop /1/.

It takes 4 additional parameters:

* system-version - operating system name with version, servi pack and architecture (32, 64 bit)
* client-version - client version, arbitrary number greater than 1000
* client-self-ip-address - client's own external ip-address (ipv4 and ipv6) in string representation.
  Produced by the client by means chosen at the discretion of the developer of this client.
* token-string - random string from 16 to 32 characters long.
  Can contain large and small English characters and numbers from 0 to 9. Case sensitive
* devhash - hardware identifier. An arbitrary HEX string (characters 0-9, A-F) representing some 256-bit hash,
which depends on the hardware or operating system on which the client is running

Request format:
```/<group-tag>/<clientid>/0/<system-version>/<client-version>/<client-self-ip-address>/<devhash>/<token-string>/`` `

The server response is a file (content-type: binary) with the following content:

```/1/<group-tag>/<clientid>/<token-string>/<binary-content-length>/\r\n
<binary-content>\r\n
<server-sign>```

token-string - the string copied from the GET request
binary-content-length - length of the binary-content block in bytes written as a string
binary-content - block of binary data
server-sign - digital signature of the server, it includes the contents of the response from the first byte to the second newline \r\n (symbols \r\n are included in the digital signature)

If, when receiving a command, the client is not in the database, then it must be added to it, if it is, then the information in the database
(group tag, ip address, client version, operating system) must be updated.

File selection.
The block of binary data in this case is the extcfg file, which is selected according to the same rules as in the /5/ command. If

Receiving the command /0/ means that the client is online from the current moment. Possible to receive several times in a row
commands /0/ from one client is a normal situation.

## 3.2 /1/ - issuing a command to the client.

It has only one additional parameter -

  * token-string (which will be duplicated in the response).

It is allowed to process this command only if the last time the command /0/ came from this client
no more than a day ago (time may be from changed via server application config file),
otherwise, the server should respond with an HTTP 403.

The response format for this command is:

```/<incode>/<group-tag>/<clientid>/<token-string>/<cmd-id>/\r\n
<command-params>\r\n
<server-sign>```

* incode - code of the issued command
* token-string - string copied from command parameter /1/ from GET request
* cmd-id - unique identifier of the issued command, an arbitrary string with large and small English characters, numbers from 0 to 9 and symbols -, +, dot, #. Case sensitive.
* command-params - an arbitrary string with parameters (must not contain \r\n characters, as this marks the end of the line)
* server-sign - digital signature of the server, it includes the contents of the response from the first byte to the second newline \r\n (symbols \r\n are included in the digital signature)

## 3.3 /5/ - issuing a file to the client.

It has only one additional parameter - the file name. The file name is not case sensitive.
In response to this command, the server should issue a file (content-type: binary) intended for this client.

The internal storage of the server application (database) must contain an arbitrary number of files,
each file can be filtered by the following parameters:
  group filter (specified by a list of like-patterns separated by spaces),
  group exclusion filter (specified by a list of like-patterns separated by spaces, if there is at least one match from this list, then the file is considered not suitable for the client),
  geoip,
  operating system,
  importance (range start-end),
  userdefined (range start-end),
  client id (strict match),
  priority.

The priority is an arbitrary positive integer.
The group tag can be specified not only by the strict name of the group, but also as a like-pattern from the SQL language.
The server can have multiple files with the same name but different filters.
If several files are suitable for the client at once, then the one with a higher priority value in the filter should be issued
than the rest. The database must not allow specifying multiple files with the same priority.

If there is no file that satisfies the conditions for this client, then the server should respond with an HTTP 404.

If a request came from a client from which a request /0/ never came, then only the group tag should be checked for him
(since there is no other information in the database yet).

## 3.4 /10/ - receiving from the client a report on the command executed by him.

Request format for the /10/ command:

```/<group-tag>/<clientid>/10/<incode>/<cmd-id>/<result-code>/```

incode - code of the executed command
cmd-id - ID of the executed command.
result-code - result code of the executed command. Number from 0 to 999

Upon receipt of this command, the command that is in the queue for this client must be removed from the queue
OUTSIDE depending on what result-code the client sent.

If there is no command in the queue with the specified code and ID specified in the incode and cmd-id parameters (mandatory
checking both values), then this is considered an abnormal situation and should be recorded in some log or other
an entity that the server administrator can then view.

The response to this command is always the same HTTP 200, Content-type: text/plain, response body content "/1/"

## 3.5 /14/ - saving a key-value pair in the database.

To be able to view these values ​​by an administrator or operator.
Request format:
```/<group-tag>/<clientid>/14/<name>/<value>/0/```

* name - key. An arbitrary string with English uppercase and lowercase letters, numbers and dot, "+" and "-" symbols.
* value - value. Arbitrary string, all special characters must be encoded in urlencode.
* The third parameter is always zero.


The response to this command is always the same HTTP 200, Content-type: text/plain, response body content "/1/"

## 3.6 /15/ - reading a key-value pair from the database.

```/<group-tag>/<clientid>/15/name```

Result:
    HTTP 200 -- body: value
    HTTP 204 -- value not found

## 3.7 /23/ - issuing a config to the client.

It has only one additional parameter - the version of the current client config. The version is a number between 0 and 2^32-1.
Client request example:
```/<group-tag>/<clientid>/23/<current-config-version>/```
current-config-version - current config version.

Server response example:
```/23/<group-tag>/<clientid>/<config-version>/<binary-content-length>/\r\n
<binary-content>\r\n
<server-sign>```
  binary-content - binary content of the config
  config-version - config version in binary-content
  binary-content-length - length of binary-content in bytes written as a string

The internal storage of the server application (database) must contain an arbitrary number of configs.
Like a file, the config has an integral parameter - version - an arbitrary numerical value that is set by the administrator or higher-level logic.
Each config can have a filter by the following parameters:
  * group tag (can be set as a like-pattern and from the SQL language),
  * geoip,
  * operating system,
  * importance (range start-end),
  * userdefined (range start-end),
  * client id (strict match).
  
The server can have several configs with the same version but with different filters.
All configs with a version equal to or less than the one specified by the client in the request are discarded.
The client can be given a config with a version strictly greater than the one he specified in the request.
If several configs suit the client at once, then the one with a higher version than the others should be issued.
The database must be able to allow storage of configs with the same version.
If there is no file that satisfies the conditions for this client, then the server should respond with an HTTP 404.
If a request came from a client from which a request /0/ never came (or it came a long time ago), then the server responds immediately with HTTP 403, without any checks.

## 3.8 /25/ - issuing a link to the client.

The command has no parameters.
Client request example:
```/<group-tag>/<clientid>/25/<token-string>/```
token-string - identical to the parameter in the /1/ command

Server response example:
```/25/<group-tag>/<clientid>/<token-string>/\r\n
<link>\r\n
<server-sign>```
The server application's internal storage (database) must contain an arbitrary number of links.

A link is an arbitrary string built according to the rules of a URL.
Like files and configs, the link has an inherent parameter - the expiration date in minutes, from the moment it was added by the administrator or higher-level logic.

Each link can be filtered by the following parameters:
  * group tag (can be set as a like-pattern from the SQL language),
  * geoip,
  * operating system,
  * importance (range start-end),
  * userdefined (range start-end),
  * client id (strict match).

The server can have several identical links, but with different filters.
When fetching a link for a client, all links that have expired must be discarded.
If several links are suitable for the client at once, then the one whose relevance expires later than all the others should be issued (namely, relevance, i.e. date-time of adding + expiration date in minutes).
If there is no link matching the given client, then the server should respond with an HTTP 404.
If a request came from a client from which a request /0/ never came (or it came a long time ago), then the server responds immediately with HTTP 403, without any checks.

# 3.9 /63/ - receiving module data.

The command has the following parameters:
  * module name,
  * ctl to module,
  * resulting string ctl,
  * helper tag,
  * ctl_OutData.
  
Moreover, the resulting ctl string, auxiliary tag and ctl OutData are optional.
The parameter "ctl_OutData" is a block of arbitrary binary data and is passed in the body via multipart/form-data, the name of the parameter inside multipart/form-data is "noname".
If ctl_OutData is present in the request, then the request is sent using the POST method.

Customer request example
```/63/<module name>/<ctl>/<ctl-result-string>/<aux-tag>/```

* module name - the string consists of English letters only, the maximum length is 64 characters. It is assumed that this column in the table will have an index.
* ctl - the string consists of only English letters and numbers, the maximum length is 64 characters.
* ctl-result-string - string in base64 format. The backend must store this string in the database in decoded form. Maximum length after decoding 1024 symbols
* aux-tag - auxiliary tag, the string consists of only English letters and numbers, the maximum length is 128 characters. The field is necessary for the convenience of searching in the table; it is assumed that this column in the table will have an index.
* ctl_OutData - passed in the body of the POST request and contains a block of arbitrary binary data. The maximum size is 32 MB.

The server response is either always 200 - "/1/", or 403 if the client is not in the database or he sent /0/ too long ago
The server must store all information received via the /63/ command, namely:

  * date Time,
  *clientid,
  *ctl,
  * ctl-result-string,
  * aux tag
  * ctl_OutData.
  
All information should be stored in separate columns for selection and filtering (of course, except for ctl_OutData, a column with a binary data type is enough for it).

## 3.10 /64/ - event report in the module.

The command has the following parameters:
* module name,
* event name,
* event information,
* helper tag,
* event data.

Moreover, the information about the event, auxiliary tag and data are optional.

The event information is a UTF-8 encoded string with a maximum length of 64 KB (bytes, not characters).

The data parameter is a block of arbitrary binary data and is passed in the body via multipart/form-data,

The name of the parameter inside multipart/form-data is "data" and the name of the parameter with the event information is "info".

If the request contains data or information about the event, then the request is transmitted using the POST method.

At customer request measures
```/64/<module name>/<event-name>/<aux-tag>/```

module name - the string consists of English letters only, the maximum length is 64 characters. It is assumed that this column in the table will have an index.

event-name - the string consists of only English letters and numbers, the maximum length is 64 characters.

aux-tag - auxiliary tag, the string consists of only English letters and numbers, the maximum length is 128 characters.
  The field is necessary for the convenience of searching in the table; it is assumed that this column in the table will have an index.

The server response is either always 200 - "/1/", or 403 if the client is not in the database or he sent /0/ too long ago
The server must store all information received via the /64/ command, namely:
 
* date Time,
*clientid,
* event name,
*info,
* aux tag
*data.

All information should be stored in separate columns for selection and filtering (of course, except for data, a column with a binary data type is enough for it).

# 4. Each client must have its own command queue.
 
Commands are added to the queue by the operator or by certain mechanisms of the server application.
Commands are removed from the queue only when the client sends a report about their execution using the /10/ command.
Until the report arrives, the command will queue up, EVEN if this results in the client requesting several
times the same command. Upon receipt of a progress report, the command must be removed from the queue, regardless of whether
what result-code the client sent.

Each command has two attributes:
  * command code (a number from 0 to 999)
  * command parameter - ANSI string of arbitrary length.
  
# 5. Digital signature of the server
which appears in the response of some commands is an ECDSA 256bit signature.
It is not used in the current version, instead it should be the string "1234567890"

#6 DataPost

is a separate version of the server application that ONLY accepts the /60/ command and nothing else.
6.1 /60/ - not used in the current version of the system

#7 IdleCommands functionality.

The server must provide some API (in the form of stored procedures) that will create "pending commands".
The pending command functionality implies that there is a group of commands that does not initially have recipient clients.
Each pending command group has the following parameters:
  * command code,
  * command parameter,
  * number of commands,
  * geoip filters (up to 10 countries)
  * operating system filter
  * group filter. The filter can be specified as a like-pattern from the SQL language, or several like-patterns separated by spaces
  * exclusive group filter. The filter can be specified as a like-pattern from the SQL language, or several like-patterns separated by spaces. If a client's group tag matches at least one of the patterns listed in this parameter, then the pending command is considered NOT a match for it. The consistency of this setting with the previous setting is provided by the administrator.
  * importance filter (beginning and end of range)
  * filter user defined (beginning and end of the range).
  
Each incoming request /1/ of the client, if it does not have outstanding commands in the queue, is checked against the filters of "waiting commands" groups, while those groups from which commands were previously issued to this client should be excluded.
If such filters are found, then the first filter is taken (if there are more than one), the counter of commands in this group is reduced by one, after which the command code and its parameter are added to the command queue of this client.
An important requirement: a command can be issued only once to one client from each group of "waiting commands".
It is also necessary to provide functionality for managing groups of "waiting commands". Final functionality (stored procedures):
1. add a group
2. delete a group
3. get a list of groups (in the list, each group should have all the parameters, plus the number of remaining teams in the group and the initial number of teams in the group)
4. increase the number of commands (take care of the atomicity of the operation and resolve the conflict, when the number became negative due to the simultaneous operations of the admin and backends)
5. change the command parameter (but not the command code)
6. add a country to the filters (cannot be removed)

#8 server management API.

The server on a separate port provides an API to control some of the server's functions. The API port must be configured through the server config.

8.1 API access occurs
over HTTPS, regardless of the server port number. An HTTP request can be either GET or POST. A POST request is used if one of the API arguments is provided as a binary data block. Access control is based on two parameters: apikey and apikeypass.

8.1.1 The API request format looks like this:

```/<apikey>/<apikeypass>/<function>?param_name1=<param1>&param_name2=<param2>.....```

If the function accepts some binary data block, then the request is made using the POST method, and the data block is transmitted inside multipart/form-data with the name "bdata"

function-function name, string is case sensitive, can contain uppercase and lowercase English letters and numbers

8.2 Each apikey has the following attributes:
  a list of functions that he is allowed to perform,
  the range of ip-addresses from which he is allowed to access.
  
  The range is given in CIDR format. For example, 1.2.3.4/24 is a range from 1.2.3.0 to 1.2.3.255, 1.2.3.4/32 is a single ip address, 1.2.3.4/0 is any ip address.

A list of all apikeys and apikeypasses with their settings (list of functions and ip range) must be specified through a special database table

8.2.1 The requester's IP address is extracted from the "X-Forwarded-For" HTTP header. If this header is not present, then the request should be discarded with an HTTP 403 code.

## 8.3 API Functions

### 8.3.1 GetGroupData - getting information on groups.

It takes one parameter: a period of time in minutes.
The function should issue a report on activity by group for the specified period of time up to the present moment.
Data about the client is included in the report if he had activity in the specified period of time.
The group report is a text file. Group data format :

```<group> <client_count> <first_created>```

* group - group name
* client_count - number of unique clients
* first_created - first registration time of the earliest client in this group. Time format: epoch time.

Group information lines are separated by the "\r\n" pair.

For example:

```qwerty1 151 1451278532
test 12 1358237562
test2 1005 1428237531
test111 100 1438257732```

If successful, the function responds with HTTP 200 with a text file with data on groups, otherwise 403 (if the parameters are not specified, the format is incorrect, the apikey / apikeypass data is incorrect, or there is an error somewhere).

### 8.3.2 UploadFile - uploading a file to the server.

It accepts parameters in the following order:

* id - number (if a specific replacement file is addressed)
* filename (filename)
* group -- group. (if not specified then "*")
* sys_ver (if not specified then "*")
* country (if not specified then "*")
* client_id (if not specified then 0)
* importance_low (if not specified then 0)
* importance_high (if not specified then 100)
* userdefined_low (if not specified then 0)
* userdefined_high (if not specified then 100)
* priority (number)
* bdata -- file content inside multipart/form-data

Before uploading a file to the database, the file priority is calculated as follows: the maximum priority value in the table is calculated and one is added.
The function responds with HTTP 200 /1/ if successful, otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data or some error).

### 8.3.3 UploadConfig - uploading the config to the server.

* id -- if you need to replace the link
* version config version
* group
* country (if not specified then "*")
* client_id (if not specified then 0)
* importance_low (if not specified then 0)
* importance_high (if not specified then 100)
* userdefined_low (if not specified then 0)
* userdefined_high (if not specified then 100)
* sys_ver
* bdata -- config content inside multipart/form-data

The function responds with HTTP 200 /1/ if successful, otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data or some error).

### 8.3.4 UploadLink - uploading a link to the server.

* id -- if you need to replace the link
* expiry_at -- unixtime (integer) - link expiration time
* sys_ver -- system version
* group -- group
* country -- country
* client_id (if not specified then 0)
* importance_low (if not specified then 0)
* importance_high (if not specified then 100)
* userdefined_low (if not specified then 0)
* userdefined_high (if not specified then 100)
* bdata -- full link text inside multipart/form-data

The function responds with HTTP 200 /1/ if successful, otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data or some error).

### 8.3.5 PushBack - adding a command to the client's queue

* cid - string identifier of the client. The part of the identifier after the dot. For example, 4D2873436FA2371F319DD55C147DC9B2
* code - command code, number
* param - command parameter, string. When passed through a GET link, it can be in urlencode format

The function responds with an HTTP 200 /1/ if successful, if the non-existent cid is 404.
Otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data, or an error somewhere).

### 8.3.6 GetFilesList - get a list of all files with all parameters.

The function, if successful, responds with an HTTP 200 text/plain listing all the files that are in the file table.
One line - one file, line separator - "\r\n". The intra-line parameter separator is a tab (9).
The parameters are in the following order: id, name, priority, group, geo, importance_low, importance_high, system, userdefined_low, userdefined_high.

Otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data, or an error somewhere).


### 8.3.7 DeleteFile - deleting a file
* id - identifier of the file to be deleted

The function, if successful, responds with HTTP 200 /1/ if the non-existent id is 404. Otherwise, 403 (if the parameters are not specified, the format is wrong, the apikey/apikeypass data is incorrect, or there is an error somewhere).

### 8.3.8 GetLastEventData - get the latest data from the specified module and event
* cid - string identifier of the client. The part of the identifier after the dot. For example, 4D2873436FA2371F319DD55C147DC9B2
* module - module name
* event - event name

If successful, the function responds with HTTP 200 and octet-stream with the content of the data sent last time for the specified module and event, if the cid does not exist - 404, if there is no event that satisfies the requirements (module, event) - 404, if there is an event, but data no, then 204. Otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data, or somewhere an error).

### 8.3.9 GetOnline - get a list of all clients by last activity.
* period - activity period in seconds.

The function, if successful, responds with an HTTP 200 text/plain listing the string IDs of the clients that were active during the specified time period.

One line - one identifier, line separator - "\r\n". Specify only the part after the dot in the identifier.

Otherwise 403 (if parameters are not specified, wrong format, wrong apikey/apikeypass data, or an error somewhere).

### 8.3.10 GetLastActivity - get the time of the client's last activity
* cid - string identifier of the client. The part of the identifier after the dot. For example, 4D2873436FA2371F319DD55C147DC9B2

The function, if successful, responds with HTTP 200 and text/plain in which, as a string, is the EPOCH-time with the last activity of the specified client, if the non-existent cid is 404. Otherwise, 403 (if parameters are not specified, incorrect format, incorrect data apikey / apikeypass or some mistake).

### 8.4.11 GetEventsGroup - get events in the specified time range by the specified modulo.

* module is the name of the module.
* from -- date from which we start sampling (YYYY-MM-DD HH:MM:SS)
* to -- date until which we select the sample (YYYY-MM-DD HH:MM:SS)

Result:

    7E1CA48485E507C4D1490765637E019B - /FF-14-08/Chrome-14-08/Edge-14-08/IE-14-08/
    49DABAE0E9C47C9C04A274A84E511113 - /Chrome-10-08/IE-07-08/


### 8.4 All API activity must be logged.

The following information should be stored: date-time, apikey, search address, function. Store information only about successfully completed requests, all the rest are logged into the general text log of the server.

#9 Client log.

Each client should have its own activity log.
This activity log should contain information about all commands to the server except for the /1/ command.
Information about all issued commands to the client should also be entered.
If a command from the commands_idle groups was issued, then the commands_idle group identifier must be stored.

The activity log should store the following information:

* date Time
*client_id
* command code, incoming or outgoing.
* Additional information as a string.
 
** There will be no information for outgoing commands.
** Upon receipt of the /10/ command, the code of the executed command must be saved in this field.
** In case of "non-idle" execution of the /1/ command, the code of the issued command should be saved in this field.
** For commands_idle, this will be the group id.
** For /63/ this will be the module name and ctl (space separated).
** For /64/ this will be the module name and event name and aux-tag (separated by a space).
** For /23/ this will be the version of the given config.
** For /5/ this will be the id of the checked out file.
** For /25/ this will be the text of the link.
** For /10/ this will be the id of the executed command (cmdid) and the result code.
 
#10 Importance.

The Importance mechanism should allow the formation of an integer value from 0 to 100 inclusive based on events associated with the client.
 
## 10.1 Each event has Importance value modifiers, there are three of them: preplus, mul, postplus.

All are of type float with a precision of at least 4 decimal places and cannot be null and .

Preplus and postplus can take values ​​from -100 to 100 inclusive, mul can take values ​​from 0 to 100 inclusive.

Also, the event has a class and an additional parameter depending on the class.

There can be any number of events with the same class, but there cannot be two events with the same class and additional parameter.

For each client, the event can only fire once.

After the event has fired, the importance value is recalculated using the following formula:

newimportance = (oldimportance+preplus)*mul+postplus

If newimportance is less than 0 or greater than 100, then it is assigned a value of 0 or 100, respectively.
Also, before saving to the database, the value of newimportance will be rounded to an integer value using the standard rounding function.

Among other things, each client it must have a parameter (flag) that disables the automatic change of the importance value.

By default, it is disabled for everyone.

The list of events is global for all clients.
IT should change through the DBMS, and not through the configs.
When deleting an event from the list (table) with events, no recalculation of importance occurs.
The list of events itself rarely changes (no more than once every 30 minutes), so caching the list of events is allowed.

The update frequency must be set via the config.

## 10.2 In the current implementation, the server should support the following event classes

### 10.2.1 The class is "online". Command /0/ .

An additional parameter is the number of received commands /0/ . For example, the following events are listed:
id1 - online(1), preplus=xx, mul= xx, postplus=xx
....
id16 - online(4)), preplus=xx, mul= xx, postplus=xx
....
id23 - online(7)), preplus=xx, mul= xx, postplus=xx
Thus, at the first received command /0/, the event "id1" will be triggered,
     on the second received command, the "id1" event will NOT fire,
     the third one won't work either.
     and on the fourth received command /0/ the "id16" event will be triggered,
     at the fifth and sixth commands /0/ the events "id1" and "id16" will not work,
     at the seventh received command /0/ the "id23" event will be triggered.

If the parameter is 0 or null, then it is treated as one.

### 10.2.2 The class is "age". time after registration.

An additional parameter is the number of minutes elapsed since the very first /0/ command that caused the client to register in the database.

The number of minutes is compared according to the "greater than or equal to" (">=") operation.

Checking for an event occurs only when a /0/ or /1/ command is received.

For example, there are the following events:

id2-age(30), preplus=0, mul= 1.0, postplus=10
....
id15- age(90), preplus=0, mul= 0.2, postplus=0

Thus, when the /0/ or /1/ command is received, it turned out that 37 minutes have passed since the client registered, then the "id2" event fires.
Then, if upon receipt of /0/ or /1/ it turned out that 123 minutes have passed, then "id15" will work.
As a result, the value of importance will be equal to 2 (in the beginning importance is equal to 0, then after "id2" it will be (0+0)*1+10 = 10, and then after "id15" it will be (10+0)*0.2+0=2 )

Another option is also possible: at some point, when the command /0/ or /1/ was received, it turned out that 201 minutes had passed since the client registered,
then both the "id2" event and the "id15" event will fire at the same time. In this case, we will get both events firing at the same time, the same calculations, and importance = 2.

### 10.2.3 The class is "geo". The country.

Additional parameter - country name, string. Checking for an event is performed only when the /0/ command is received.

### 10.2.4 The class is "devhash_dup". There is another client that has exactly the same devhash.

The optional parameter is not used.

Checking for an event is performed only when the /0/ command is received. The event is triggered if, when receiving the /0/ command, when saving it to a table, it turns out that another client has exactly the same one in devhash.

### 10.2.5 The class is "command_complete". Successful execution of the outgoing command.

An additional parameter is the number of executed commands.
Checking for an event is performed only when the /10/ command is received.
If the parameter is 0 or null, then it is treated as one.

### 10.2.6 The class is "geo_change".

Country change. There are no additional options.
Checking for an event is performed only when the /0/ command is received.

## 10.3 For each triggered event in the log of the desired client (point 9) there should be an entry with the identifier of the triggered event


online class - individual counter
class age - global, time is counted from the time specified in the created_at column
geo class - no counter needed
class devhash_dup - counter is not needed
command_complete class - individual counter

## 11 Mechanism for auto-adding commands to the client

Implement a mechanism for auto-adding commands to the client when receiving event reports (command 64).

The auto-add trigger must respond to the module name, event name, and info field; when they occur, the server must add a command with the specified code and parameter.

The info field must be validated against a regular expression.
Thus, if the info field contains "qrrr45werty", then checking against "r45" should give a positive result, and checking against "^r45" should give a negative result.

Among other things, the trigger must contain an integer parameter that limits the minimum frequency of operation of this trigger on each particular client.
The parameter is set in seconds.
If it is 0, then there is no limit.
For example, if it is equal to 300 seconds, then if the trigger worked for this client 180 seconds ago, then the command does not need to be inserted into the queue.
 
The auto-add list must be managed through a table.

The table can be cached, the regularity of the cache update must be set via the config in seconds.

-------------------------------

## 12 Promoved filter

Incomprehensible bots are knocking on the admin panel,
 you need to add a filter to filter out such bots, do not give them configs (commands 23, 5) and
 commands for launching modules and files (commands 42, 43, 44, 45, 46, 47, 48, 50, 62):
 1) by ip (you can specify specific ip, or a whole range)
 2) by id:
  Kevin_W617601* - all bots whose id starts with Kevin_W617601
  *Kevin* - all bots containing Kevin in id
  you can specify a list of such filters
 3) By Version:
 Version < 1080
 version == 1027
 Version != 1089
 Version > 1099
 4) by Group:
 aver*
 5) by System:
 Microsoft Windows 10 Pro
Microsoft Windows 7 Professional
Microsoft*
*Microsoft*
 These filters can be grouped, for example:
  Version < 1080
  System: *Microsoft*
etc.

Make filter management via api, or as you did for mavelek, so that he makes a section in the admin panel
